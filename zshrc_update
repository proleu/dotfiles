# Somewhat unsafely check for .bashrc and collect any PATH mods from it
if [ -f "$HOME/.bashrc" ]; then
    grep 'export PATH=' "$HOME/.bashrc" | while read -r line; do
        case "$line" in
            export\ PATH=*) eval "$line" ;;
            *) ;;
        esac
    done
fi

# Add uv path script if it exists
if [ -f "$HOME/.local/bin/setup_uv_path.sh" ]; then
    source "$HOME/.local/bin/setup_uv_path.sh"
else
    # Fallback path settings if script doesn't exist
    if [ -d "$HOME/.local/bin" ]; then
        export PATH="$HOME/.local/bin:$PATH"
    fi
    if [ -d "$HOME/.cargo/bin" ]; then
        export PATH="$HOME/.cargo/bin:$PATH"
    fi
fi

# Auto-activation of Python environments is handled by the activate_dotfiles_env function

# Auto-activate pipenv for projects with Pipfile
function auto_pipenv_shell() {
    # Skip activation in home directory and dotfiles directory (since we have our own handling there)
    if [[ "$PWD" == "$HOME" ]] || [[ "$PWD" == "$HOME/"* && "$PWD" != "$HOME/dotfiles" ]] || [[ "$PWD" == "$HOME/dotfiles" ]]; then
        return
    fi
    
    if [ -f "Pipfile" ]; then
        if [ "$PIPENV_ACTIVE" != "1" ] && [ -z "$VIRTUAL_ENV" ]; then
            echo "Pipfile detected, activating pipenv shell..."
            # Use PIPENV_IGNORE_VIRTUALENVS to ensure we create a proper project venv
            PIPENV_IGNORE_VIRTUALENVS=1 pipenv shell
        fi
    fi
}

# Add the auto-activate function to directory change hook
chpwd_functions=(${chpwd_functions[@]} "auto_pipenv_shell")

# Ensure virtualenv/pipenv environment bin directory is at the front of PATH
if [ -n "$VIRTUAL_ENV" ]; then
    # Move VIRTUAL_ENV/bin to front of PATH
    PATH="${VIRTUAL_ENV}/bin:${PATH}"
    # Rehash to update command paths
    hash -r 2>/dev/null || true
fi

# History
setopt histignorealldups sharehistory
HISTSIZE=SAVEHIST=10000
HISTFILE=$HOME/.zsh_history

# Theme
ZSH_THEME="robbyrussell"

# Paths
fpath+=${ZSH_CUSTOM:-${ZSH:-~/.oh-my-zsh}/custom}/plugins/zsh-completions/src
export ZSH="$HOME/.oh-my-zsh"

# Plugins
plugins=(
    fzf 
    git 
    history-substring-search 
    ohmyzsh-full-autoupdate 
    zsh-autosuggestions 
    zsh-completions 
    zsh-vi-mode
)

# Source Oh-My-Zsh
source $ZSH/oh-my-zsh.sh

# User Configuration
export EDITOR='nvim'

# Aliases
alias b="cd .."
alias bb="cd ../.."
alias bbb="cd ../../.."
alias bbbb="cd ../../../.."
alias bbbbb="cd ../../../../.."
alias bbbbbb="cd ../../../../../.."
alias lzd="lazydocker"
alias pnuke="perl -e 'for(<*>){unlink}'"
alias so="source $HOME/.zshrc"


# Auto-activate dotfiles Python environment when in dotfiles directory
function activate_dotfiles_env() {
    # Only activate when in dotfiles directory and not already in a virtual environment
    if [[ "$PWD" == "$HOME/dotfiles" ]] && [ -z "$VIRTUAL_ENV" ]; then
        DOTFILES_ACTIVATE="${HOME}/dotfiles/.venv/bin/activate"
        if [ -f "$DOTFILES_ACTIVATE" ]; then
            # Direct activation preserves more shell settings
            source "$DOTFILES_ACTIVATE"
            echo "Dotfiles Python environment activated"
        fi
    # Deactivate when leaving dotfiles directory and we're in the dotfiles venv
    elif [[ "$PWD" != "$HOME/dotfiles" ]] && [[ "$VIRTUAL_ENV" == "$HOME/dotfiles/.venv" ]]; then
        deactivate
        echo "Dotfiles Python environment deactivated"
    fi
}

# Add the auto-activate function to directory change hook
chpwd_functions=(${chpwd_functions[@]} "activate_dotfiles_env")


# Functions
function count_pdbs() { find -type f -name "*.pdb*" | wc -l; }
function fetch() { wget http://www.rcsb.org/pdb/files/$1.pdb.gz || wget ftp://ftp.wwpdb.org/pub/pdb/data/structures/all/pdb/pdb$1.ent.gz; }
function gh_auth() { BROWSER=false gh auth login --web }
function mcd() { mkdir -p $1; cd $1; }
function swap() {
    local TMPFILE=tmp.$$
    mv "$1" $TMPFILE
    mv "$2" "$1"
    mv $TMPFILE "$2"
}

function fetch_aws_batch_logs() {
    local log_stream_name=$1
    local cmd="aws logs get-log-events --log-group-name /aws/batch/job --log-stream-name ${log_stream_name} --start-from-head --output text"
    local response=$(eval "$cmd") || return 1

    while :; do
        if [[ $(wc -l <<< "$response") -eq 1 ]]; then
            break
        fi

        tail -n +2 <<< "$response"
        local meta=($(head -n 1 <<< "$response"))
        response=$(eval "$cmd --next-token ${meta[1]}") || return 1
    done
}
